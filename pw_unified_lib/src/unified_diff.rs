// generated by lap_gen.

use crate::parser_attributes::*;
use lalr1::Parser;

#[derive(Debug, Default, Clone)]
pub struct UnifiedChunk {
    pub header: String,
    pub lines: Vec<String>,
}

#[derive(Debug, Default, Clone)]
pub struct UnifiedDiff {
    pub before: String,
    pub after: String,
    pub header: String,
    pub chunks: Vec<UnifiedChunk>,
}

#[derive(Debug, Default, Clone)]
pub struct UnifiedDiffs {
    pub preamble: Option<String>,
    pub diffs: Vec<UnifiedDiff>,
}

impl UnifiedDiffs {
    pub fn new(text: &str) -> Self {
        let mut unified_diffs = UnifiedDiffs::default();
        unified_diffs.parse_text(text, "unified_diffs").unwrap();
        unified_diffs
    }

    pub fn start_new_diff(&mut self, before: &str, after: &str) {
        let mut diff = UnifiedDiff::default();
        diff.before = before.to_string();
        diff.after = after.to_string();
        self.diffs.push(diff);
    }

    pub fn start_new_chunk(&mut self, chunk_header: &str) {
        let mut chunk = UnifiedChunk::default();
        chunk.header = chunk_header.to_string();
        self.diffs
            .last_mut()
            .expect("start_new_chunk")
            .chunks
            .push(chunk);
    }

    pub fn add_chunk_line(&mut self, chunk_line: &str) {
        let line = chunk_line.to_string();
        self.diffs
            .last_mut()
            .expect("add_chunk_line:1")
            .chunks
            .last_mut()
            .expect("add_chunk_line:2")
            .lines
            .push(line);
    }
}

impl lalr1::ReportError<AATerminal> for UnifiedDiffs {}

use std::collections::BTreeSet;

macro_rules! btree_set {
    () => { BTreeSet::new() };
    ( $( $x:expr ),* ) => {
        {
            let mut set = BTreeSet::new();
            $( set.insert($x); )*
            set
        }
    };
    ( $( $x:expr ),+ , ) => {
        btree_set![ $( $x ), * ]
    };
}

#[derive(Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq)]
pub enum AATerminal {
    AAEnd,
    AfterPath,
    BeforePath,
    ChunkHeader,
    ChunkLine,
    Preamble,
}

impl std::fmt::Display for AATerminal {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AATerminal::AAEnd => write!(f, r###"AAEnd"###),
            AATerminal::AfterPath => write!(f, r###"AfterPath"###),
            AATerminal::BeforePath => write!(f, r###"BeforePath"###),
            AATerminal::ChunkHeader => write!(f, r###"ChunkHeader"###),
            AATerminal::ChunkLine => write!(f, r###"ChunkLine"###),
            AATerminal::Preamble => write!(f, r###"Preamble"###),
        }
    }
}

lazy_static::lazy_static! {
    static ref AALEXAN: lexan::LexicalAnalyzer<AATerminal> = {
        use AATerminal::*;
        lexan::LexicalAnalyzer::new(
            &[
            ],
            &[
                (Preamble, r###"([^-]{3}*)"###),
                (BeforePath, r###"(^---.*\n)"###),
                (ChunkHeader, r###"(^@@.*@@.*\n)"###),
                (ChunkLine, r###"(^[ -+].*\n)"###),
                (AfterPath, r###"(^\+\+\+.*\n)"###),
            ],
            &[
            ],
            AAEnd,
        )
    };
}

#[derive(Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq)]
pub enum AANonTerminal {
    AAStart,
    Chunk,
    Diff,
    DiffList,
    Specification,
}

impl std::fmt::Display for AANonTerminal {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AANonTerminal::AAStart => write!(f, r"AAStart"),
            AANonTerminal::Chunk => write!(f, r"Chunk"),
            AANonTerminal::Diff => write!(f, r"Diff"),
            AANonTerminal::DiffList => write!(f, r"DiffList"),
            AANonTerminal::Specification => write!(f, r"Specification"),
        }
    }
}

impl lalr1::Parser<AATerminal, AANonTerminal, ParserAttributes> for UnifiedDiffs {
    fn lexical_analyzer(&self) -> &lexan::LexicalAnalyzer<AATerminal> {
        &AALEXAN
    }

    fn viable_error_recovery_states(_token: &AATerminal) -> BTreeSet<u32> {
        btree_set![]
    }

    fn look_ahead_set(state: u32) -> BTreeSet<AATerminal> {
        use AATerminal::*;
        return match state {
            0 => btree_set![BeforePath, Preamble, AAEnd],
            1 => btree_set![AAEnd],
            2 => btree_set![BeforePath, AAEnd],
            3 => btree_set![BeforePath, AAEnd],
            4 => btree_set![BeforePath, ChunkHeader, AAEnd],
            5 => btree_set![AfterPath],
            6 => btree_set![BeforePath, ChunkHeader, AAEnd],
            7 => btree_set![BeforePath, AAEnd],
            8 => btree_set![BeforePath, ChunkHeader, ChunkLine, AAEnd],
            9 => btree_set![BeforePath, ChunkHeader, ChunkLine, AAEnd],
            10 => btree_set![BeforePath, ChunkHeader, AAEnd],
            11 => btree_set![BeforePath, ChunkHeader, ChunkLine, AAEnd],
            _ => panic!("illegal state: {state}"),
        };
    }

    fn next_action(&self, aa_state: u32, aa_token: &lexan::Token<AATerminal>) -> lalr1::Action {
        use lalr1::Action;
        use AATerminal::*;
        let aa_tag = *aa_token.tag();
        return match aa_state {
            0 => match aa_tag {
                BeforePath => Action::Shift(5),
                Preamble => Action::Shift(3),
                // DiffList: <empty> #(NonAssoc, 0)
                AAEnd => Action::Reduce(3),
                _ => Action::SyntaxError,
            },
            1 => match aa_tag {
                // AAStart: Specification #(NonAssoc, 0)
                AAEnd => Action::Accept,
                _ => Action::SyntaxError,
            },
            2 => match aa_tag {
                BeforePath => Action::Shift(5),
                // Specification: DiffList #(NonAssoc, 0)
                AAEnd => Action::Reduce(1),
                _ => Action::SyntaxError,
            },
            3 => match aa_tag {
                BeforePath => Action::Shift(5),
                // DiffList: <empty> #(NonAssoc, 0)
                AAEnd => Action::Reduce(3),
                _ => Action::SyntaxError,
            },
            4 => match aa_tag {
                ChunkHeader => Action::Shift(9),
                // DiffList: Diff #(NonAssoc, 0)
                BeforePath | AAEnd => Action::Reduce(4),
                _ => Action::SyntaxError,
            },
            5 => match aa_tag {
                AfterPath => Action::Shift(10),
                _ => Action::SyntaxError,
            },
            6 => match aa_tag {
                ChunkHeader => Action::Shift(9),
                // DiffList: DiffList Diff #(NonAssoc, 0)
                BeforePath | AAEnd => Action::Reduce(5),
                _ => Action::SyntaxError,
            },
            7 => match aa_tag {
                BeforePath => Action::Shift(5),
                // Specification: Preamble DiffList #(NonAssoc, 0)
                AAEnd => Action::Reduce(2),
                _ => Action::SyntaxError,
            },
            8 => match aa_tag {
                ChunkLine => Action::Shift(11),
                // Diff: Diff Chunk #(NonAssoc, 0)
                BeforePath | ChunkHeader | AAEnd => Action::Reduce(7),
                _ => Action::SyntaxError,
            },
            9 => match aa_tag {
                // Chunk: ChunkHeader #(NonAssoc, 0)
                BeforePath | ChunkHeader | ChunkLine | AAEnd => Action::Reduce(8),
                _ => Action::SyntaxError,
            },
            10 => match aa_tag {
                // Diff: BeforePath AfterPath #(NonAssoc, 0)
                BeforePath | ChunkHeader | AAEnd => Action::Reduce(6),
                _ => Action::SyntaxError,
            },
            11 => match aa_tag {
                // Chunk: Chunk ChunkLine #(NonAssoc, 0)
                BeforePath | ChunkHeader | ChunkLine | AAEnd => Action::Reduce(9),
                _ => Action::SyntaxError,
            },
            _ => panic!("illegal state: {aa_state}"),
        };
    }

    fn production_data(production_id: u32) -> (AANonTerminal, usize) {
        match production_id {
            0 => (AANonTerminal::AAStart, 1),
            1 => (AANonTerminal::Specification, 1),
            2 => (AANonTerminal::Specification, 2),
            3 => (AANonTerminal::DiffList, 0),
            4 => (AANonTerminal::DiffList, 1),
            5 => (AANonTerminal::DiffList, 2),
            6 => (AANonTerminal::Diff, 2),
            7 => (AANonTerminal::Diff, 2),
            8 => (AANonTerminal::Chunk, 1),
            9 => (AANonTerminal::Chunk, 2),
            _ => panic!("malformed production data table"),
        }
    }

    fn goto_state(lhs: &AANonTerminal, current_state: u32) -> u32 {
        return match current_state {
            0 => match lhs {
                AANonTerminal::Diff => 4,
                AANonTerminal::DiffList => 2,
                AANonTerminal::Specification => 1,
                _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
            },
            2 => match lhs {
                AANonTerminal::Diff => 6,
                _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
            },
            3 => match lhs {
                AANonTerminal::Diff => 4,
                AANonTerminal::DiffList => 7,
                _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
            },
            4 => match lhs {
                AANonTerminal::Chunk => 8,
                _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
            },
            6 => match lhs {
                AANonTerminal::Chunk => 8,
                _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
            },
            7 => match lhs {
                AANonTerminal::Diff => 6,
                _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
            },
            _ => panic!("Malformed goto table: ({lhs}, {current_state})"),
        };
    }

    fn do_semantic_action<F: FnMut(String, String)>(
        &mut self,
        aa_production_id: u32,
        aa_rhs: Vec<ParserAttributes>,
        mut aa_inject: F,
    ) -> ParserAttributes {
        let mut aa_lhs = if let Some(a) = aa_rhs.first() {
            a.clone()
        } else {
            ParserAttributes::default()
        };
        match aa_production_id {
            1 => {
                // Specification: DiffList #(NonAssoc, 0)
                aa_lhs = aa_rhs[0].clone();
            }
            2 => {
                // Specification: Preamble DiffList #(NonAssoc, 0)
                self.preamble = Some(aa_rhs[1].token().lexeme().to_string());
            }
            6 => {
                // Diff: BeforePath AfterPath #(NonAssoc, 0)
                self.start_new_diff(aa_rhs[0].token().lexeme(), aa_rhs[0].token().lexeme());
            }
            8 => {
                // Chunk: ChunkHeader #(NonAssoc, 0)
                self.start_new_chunk(aa_rhs[0].token().lexeme());
            }
            9 => {
                // Chunk: Chunk ChunkLine #(NonAssoc, 0)
                self.add_chunk_line(aa_rhs[1].token().lexeme());
            }
            _ => aa_inject(String::new(), String::new()),
        };
        aa_lhs
    }
}
