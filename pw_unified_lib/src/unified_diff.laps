// Copyright 2024 Peter Williams <pwil3058@gmail.com> <pwil3058@bigpond.net.au>

%{
use crate::parser_attributes::*;
use lalr1::Parser;

#[derive(Debug, Default, Clone)]
pub struct UnifiedChunk {
    pub header: String,
    pub lines: Vec<String>,
}

#[derive(Debug, Default, Clone)]
pub struct UnifiedDiff {
    pub before: String,
    pub after: String,
    pub header: String,
    pub chunks: Vec<UnifiedChunk>,
}

#[derive(Debug, Default, Clone)]
pub struct UnifiedDiffs {
    pub preamble: Option<String>,
    pub diffs: Vec<UnifiedDiff>,
}

impl UnifiedDiffs {
    pub fn new(text: &str) -> Self {
        let mut unified_diffs = UnifiedDiffs::default();
        unified_diffs.parse_text(text, "unified_diffs");
        unified_diffs
    }

    pub fn start_new_diff(&mut self, before: &str, after: &str) {
        let mut diff = UnifiedDiff::default();
        diff.before = before.to_string();
        diff.after = after.to_string();
        self.diffs.push(diff);
    }

    pub fn start_new_chunk(&mut self, chunk_header: &str) {
       let mut chunk = UnifiedChunk::default();
        chunk.header = chunk_header.to_string();
        self.diffs.last_mut().expect("start_new_chunk").chunks.push(chunk);
    }

    pub fn add_chunk_line(&mut self, chunk_line: &str) {
        let line = chunk_line.to_string();
        self.diffs.last_mut().expect("add_chunk_line:1").chunks.last_mut().expect("add_chunk_line:2").lines.push(line);
    }
}

impl lalr1::ReportError<AATerminal> for UnifiedDiffs {}

%}

%attr   ParserAttributes
%target UnifiedDiffs

%shift_reduce 2
%%

%token  BeforePath  (^---.*\n)
%token  AfterPath   (^\+\+\+.*\n)
%token  ChunkHeader (^@@.*@@.*\n)
%token  ChunkLine   (^[ -+].*\n)
%token  Preamble    ([^-]{3}*)

%%
Specification: DiffList !{ $$ = $1.clone(); !}
     | Preamble DiffList !{ self.preamble = Some($2.token().lexeme().to_string()); !}.
DiffList:
    | Diff
    | DiffList Diff
    .
Diff: BeforePath AfterPath !{ self.start_new_diff($1.token().lexeme(), $1.token().lexeme()); !}
    | Diff Chunk
    .
Chunk: ChunkHeader !{ self.start_new_chunk($1.token().lexeme()); !}
    | Chunk ChunkLine  !{ self.add_chunk_line($2.token().lexeme()); !}
    .